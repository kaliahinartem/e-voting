//Pseudocode for algorithms

------------------------------------------------------------------

Algorithm: ElGamalEnc(plaintext, pk)


Input: plaintext is a plaintext
	pk - encryption key


(p, y, g) <-- pk

r <-- getRandom(Zp)

a1 <-- (g ^ r) modq

a2 <-- (plaintext * y ^ r) modq


return (a1, a2)

ElgamalEnc encrypts given plaintext with a given key and returns ciphertext (a1, a2)

-----------------------------------------------------------------

Algorithm: ElGamalDec(cipher, sk)


input: cipher - ciphertext of ElGamal encryption
	sk - decryption key


(a1, a2) <-- cipher

plaintext <-- [a2 / (a1 ^ sk)] modq

return plaintext


ElGamalDec decrypts given ciphertext with a given secret key.

-----------------------------------------------------------------
Algorithm: KeysGeneration()


input: none


p <-- GetLargePrimeNumber()

x <-- GeneratePrivateKeyInRange(1, p-2)

g <-- Generator()

y <-- (g ^ x) modp

pubKey <-- (p, y, g)

privKey <-- x


return x, (p, y, g)


output: p - large prime number,
		g - primitive root (generator) in the group G = <Z, X>
		x - secretKey, member of the group G = <Z, X> and 1 <= x <= p - 1

KeysGeneration generates public and private key
-----------------------------------------------------------------

Algorithm: CastVote(v, pkT, pk)

input: v - voter's vote,
	pk - voter's true PK/pseudo-PK,
	pkT - election public key


r <-- getRandom(Zp)

enc_v <-- ElgamalEnc(v, pkT)

Пi <-- NIZK.Prove(v)             ??

ballot <-- (enc_v, Пi)

sign <-- Sign(ballot, pk)


return (sign)


output: sign - signed ballot

CastVote should be called by every voter's device in order to cast the vote
------------------------------------------------------------------

Algorithm: Sign( message, pK, sK )


input: message - message to be signed,
	key - key to sign the message


(p, y, g) <-- pK

r <-- getRandom((r > 1 & r < (p - 1) & gcd(k, p-1) == 1))

k <-- g ^ r modp

s <-- ( Hash(message) - sK * k )* (r ^ (-1) (modp - 1))

signature <-- (k, s)


return signature


Sign generates the signature according to elgamal signature scheme

---------------------------------------------

Algorithm: SignVerify (message, signature, pK)


input: signature - signature to be verified,
	message - original message,
	pK - key to verify the signature


(p, y, g) <-- pK

result <-- true

result <-- result && k < p && r > 0

result <-- result && s > 0 && s < p - 1

result <-- result && g ^ (Hash(message)) == y ^ k * k ^ s modp


return result (true or false);



SignVerify verifies if to accept the signature or not.
